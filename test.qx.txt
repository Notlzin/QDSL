quantum computing language (Q$)
activate::Comments{src="*" using namevector::Q, mode:Permanent};

*initializing*
|
|_init::QuantumComp::ofQ$(qubit=1000) {
|
|*set=Normal means that its a normal set of 0's and 1's, it can also go full octal*
|
|_inBetween::Qubits[set=Normal];
|
|_Qubit::simulationOverheat[default];
|
|_Qubit::simulation::FastForward[default]; *default means that its deactivated, and for simulationOverheat its true for default*
|
|_Qubit:Array[200][5]; *this means every 200 qubits it splits into 5 different groups, that means there are over 25 different groups*
|
|_Algorithm::[Grovers]; *using grovers algorithm*
|
|_Qubit::status::current: {"Cooled"};
|
|_after{ init::Return QuantumComp(): True };
|
|_set::State(|0âŸ©)
|
|_QuantumComp::CompPower[pow="100"];
|
|_RoomTemp::"-19" in[Kelvin];

};

init::void:["print"] {
    main::definition::[print]
	|
	|_input::Include(Qubit_data => Qubit_str["=Qubit[input]::=Qubit[output], n(amount.of::(Qubit[]))]);--\
	|                                                                                                    data.To::void:["print"];
	|_output::Exclude::!Input || input.Qubit::request(input=0); -----------------------------------------/
	|
	|_data::ADD input, output || =[output, input];
	|
	|_storage::Qubit.arrayStorage[input, output => Qubit::parsed(data="Str"), inf]; *"Str" means that it has to return string, or set to default for cross compatibility and inf meaning infinitely storaged*
	|
	|_qubitArray::cohere([input, output] => [data, storage]);
	|
	|_void:["parsed"]::Qubit.translate(input, output)[0][1];
	|
	|_void:[(), ""]::parsed(output) == output;
}

run::Main::{
	print("hello!")
}


